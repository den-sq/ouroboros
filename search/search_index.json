{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ouroboros or-uh-bore-us Extract ROIs from cloud-hosted medical scans. Ouroboros is a desktop app (built with Electron) and a Python package (with a CLI). The desktop app uses Docker to build and run its Python server. For this reason, Docker is required to run Ouroboros. If you are interested in using the Python package for its CLI or for a custom usecase, check out the python folder in the main repository. Ouroboros also has a Plugin System . Plugin servers are also run in Docker. Usage Guide It is recommended that you read these pages in order. Download and Install Ouroboros Slicing Backprojection Plugins Ouroboros Explanation A user of Ouroboros may have a multi-terabyte volumetric scan, hosted with the Neuroglancer family of tools (i.e. cloud-volume ). Perhaps there is a long, relatively sparse structure (ROI), like a nerve or a blood vessel that crosses the entire scan. Even with a well-equipped computer, it would be difficult to segment the entire stucture in one pass due to RAM limitations. Ouroboros provides a solution. A user first traces the structure in Neuroglancer with sequential annotation points, and then saves the JSON configuration to a file. Ouroboros opens this configuration file and cuts rectangular slices along the annotation path, producing a straightened volume with the ROI at the center of each slice (usually much smaller than the original scan). Every tenth slice in a circular annotation path, rendered in Ouroboros's Slicing Page. From there, the user segments the much smaller straightened volume with their choice of segmentation system. Then, Ouroboros backprojects the segmented slices into the original volume space (unstraightens it), producing a full segmentation.","title":"Home"},{"location":"#ouroboros","text":"or-uh-bore-us Extract ROIs from cloud-hosted medical scans. Ouroboros is a desktop app (built with Electron) and a Python package (with a CLI). The desktop app uses Docker to build and run its Python server. For this reason, Docker is required to run Ouroboros. If you are interested in using the Python package for its CLI or for a custom usecase, check out the python folder in the main repository. Ouroboros also has a Plugin System . Plugin servers are also run in Docker.","title":"Ouroboros"},{"location":"#usage-guide","text":"It is recommended that you read these pages in order. Download and Install Ouroboros Slicing Backprojection Plugins","title":"Usage Guide"},{"location":"#ouroboros-explanation","text":"A user of Ouroboros may have a multi-terabyte volumetric scan, hosted with the Neuroglancer family of tools (i.e. cloud-volume ). Perhaps there is a long, relatively sparse structure (ROI), like a nerve or a blood vessel that crosses the entire scan. Even with a well-equipped computer, it would be difficult to segment the entire stucture in one pass due to RAM limitations. Ouroboros provides a solution. A user first traces the structure in Neuroglancer with sequential annotation points, and then saves the JSON configuration to a file. Ouroboros opens this configuration file and cuts rectangular slices along the annotation path, producing a straightened volume with the ROI at the center of each slice (usually much smaller than the original scan). Every tenth slice in a circular annotation path, rendered in Ouroboros's Slicing Page. From there, the user segments the much smaller straightened volume with their choice of segmentation system. Then, Ouroboros backprojects the segmented slices into the original volume space (unstraightens it), producing a full segmentation.","title":"Ouroboros Explanation"},{"location":"guide/backproject/","text":"Backprojection After straightened volume produced by the slicing step is segmented, Ouroboros's Backproject Page can be used to project the segmentation back into the coordinate space of the original volume. Using the Backproject Page Basic Usage Demo Reusing Options from a Previous Run See the same section under Slice Page . Compression Options One of the options on the Backproject page allows the user to configure the output compression format. Common options zlib zstd none (no compression, not recommended) For more information, see Tifffile , the Python package responsible for the compression. Output Position Offset By default, the slicing output tiff image is backprojected into the space of its minimum bounding box, rather than the space of the entire source scan. The offset of the minimum bounding box is stored in the output tiff's description metadata. It is also stored in the configuration file (which is modified by the backproject step). Slicing Options \ud83d\udcc1 - Drag and drop files from File Explorer panel into this option. \ud83d\udcc1 Straightened Volume File - Path to the volume of slices to backproject (e.g. the output tif of the slicing step). \ud83d\udcc1 Slice Options File - Path to the -slice-options.json file which includes the information needed for backprojection. \ud83d\udcc1 Output File Folder - The folder to save all the resulting files into. Output File Name - Base name for all output files. Output MIP Level - The MIP level to output the backprojection in (essentially an upsample option). Use this if you downsampled in the slicing step. Upsample Order - The interpolation order Ouroboros uses to interpolate values from a lower MIP level. If you check the binary option, feel free to set this to 0. Backprojection Compression - The compression option to use for the backprojected tiff(s). Recommended options: none , zlib , zstd . Output Single File - Whether to output one tiff stack file or a folder of files. Output Min Bounding Box - Save only the minimum volume needed to contain the backprojected slices. The offset will be stored in the -configuration.json file under backprojection_offset . This value is the (x_min, y_min, z_min). Binary Backprojection - Whether or not to binarize all the values of the backprojection. Enable this to backproject a segmentation. Offset in Filename - Whether or not to include the (x_min, y_min, z_min) offset for min bounding box in the output file name. Only applies if Output Min Bounding Box is true. Max RAM (GB) - 0 indicates no RAM limit. Setting a RAM limit allows Ouroboros to optimize performance and avoid overusing RAM. How Does Backprojection Work? A large amount of helpful data is saved in *-configuration.json file after the slicing process. This data contains all of the rectangle corners from slicing, and the bounding boxes the slices are associated with. With this data, Ouroboros recalculates the 2D coordinate grids of 3D points for each slice. Trilinear Interpolation Backprojection iterates through 3D chunks of the straightened volume, as follows following order: The slices are loaded from a memmory map of the straightened volume. A custom rapid trilinear interpolation implementation is used to map the slice data into a sparse representation of the backprojected volume, limited to a bounding box containing only points associated with the chunk. As slices are completed, they are written to an uncompressed memory map of the final volume. Once all slices are completed, the final volume is compressed as either a single image or tiff stack. Why Is Interpolation Needed? The slices in the straightened volume were originally produced through interpolation. Each slice has a 2D grid of 3D points, and the values at these points were approximated through interpolation. In order to put the data back, we have to interpolate in the opposite direction. Each point contributes to the value of its neighbors based on how close it is to them.","title":"Backprojection"},{"location":"guide/backproject/#backprojection","text":"After straightened volume produced by the slicing step is segmented, Ouroboros's Backproject Page can be used to project the segmentation back into the coordinate space of the original volume.","title":"Backprojection"},{"location":"guide/backproject/#using-the-backproject-page","text":"Basic Usage Demo Reusing Options from a Previous Run See the same section under Slice Page . Compression Options One of the options on the Backproject page allows the user to configure the output compression format. Common options zlib zstd none (no compression, not recommended) For more information, see Tifffile , the Python package responsible for the compression. Output Position Offset By default, the slicing output tiff image is backprojected into the space of its minimum bounding box, rather than the space of the entire source scan. The offset of the minimum bounding box is stored in the output tiff's description metadata. It is also stored in the configuration file (which is modified by the backproject step).","title":"Using the Backproject Page"},{"location":"guide/backproject/#slicing-options","text":"\ud83d\udcc1 - Drag and drop files from File Explorer panel into this option. \ud83d\udcc1 Straightened Volume File - Path to the volume of slices to backproject (e.g. the output tif of the slicing step). \ud83d\udcc1 Slice Options File - Path to the -slice-options.json file which includes the information needed for backprojection. \ud83d\udcc1 Output File Folder - The folder to save all the resulting files into. Output File Name - Base name for all output files. Output MIP Level - The MIP level to output the backprojection in (essentially an upsample option). Use this if you downsampled in the slicing step. Upsample Order - The interpolation order Ouroboros uses to interpolate values from a lower MIP level. If you check the binary option, feel free to set this to 0. Backprojection Compression - The compression option to use for the backprojected tiff(s). Recommended options: none , zlib , zstd . Output Single File - Whether to output one tiff stack file or a folder of files. Output Min Bounding Box - Save only the minimum volume needed to contain the backprojected slices. The offset will be stored in the -configuration.json file under backprojection_offset . This value is the (x_min, y_min, z_min). Binary Backprojection - Whether or not to binarize all the values of the backprojection. Enable this to backproject a segmentation. Offset in Filename - Whether or not to include the (x_min, y_min, z_min) offset for min bounding box in the output file name. Only applies if Output Min Bounding Box is true. Max RAM (GB) - 0 indicates no RAM limit. Setting a RAM limit allows Ouroboros to optimize performance and avoid overusing RAM.","title":"Slicing Options"},{"location":"guide/backproject/#how-does-backprojection-work","text":"A large amount of helpful data is saved in *-configuration.json file after the slicing process. This data contains all of the rectangle corners from slicing, and the bounding boxes the slices are associated with. With this data, Ouroboros recalculates the 2D coordinate grids of 3D points for each slice. Trilinear Interpolation Backprojection iterates through 3D chunks of the straightened volume, as follows following order: The slices are loaded from a memmory map of the straightened volume. A custom rapid trilinear interpolation implementation is used to map the slice data into a sparse representation of the backprojected volume, limited to a bounding box containing only points associated with the chunk. As slices are completed, they are written to an uncompressed memory map of the final volume. Once all slices are completed, the final volume is compressed as either a single image or tiff stack. Why Is Interpolation Needed? The slices in the straightened volume were originally produced through interpolation. Each slice has a 2D grid of 3D points, and the values at these points were approximated through interpolation. In order to put the data back, we have to interpolate in the opposite direction. Each point contributes to the value of its neighbors based on how close it is to them.","title":"How Does Backprojection Work?"},{"location":"guide/downloading/","text":"Download Ouroboros Docker is required to run Ouroboros. Make sure to install and run it before running Ouroboros. Prebuilt applications are available in Releases . Windows: *-setup.exe Mac: *.dmg Linux: Multiple options available When you open the app, the GUI will open immediately, but the local server that runs the processing could take up a minute to start the first time it is run. There is an indicator in the GUI that shows if the server is connected. Currently, none of the apps are notarized. For Mac, if an error occurs when you try to run the app, find the app installation (should be called Ouroboros.app ) and run xattr -d com.apple.quarantine Ouroboros.app .","title":"Download Ouroboros"},{"location":"guide/downloading/#download-ouroboros","text":"Docker is required to run Ouroboros. Make sure to install and run it before running Ouroboros. Prebuilt applications are available in Releases . Windows: *-setup.exe Mac: *.dmg Linux: Multiple options available When you open the app, the GUI will open immediately, but the local server that runs the processing could take up a minute to start the first time it is run. There is an indicator in the GUI that shows if the server is connected. Currently, none of the apps are notarized. For Mac, if an error occurs when you try to run the app, find the app installation (should be called Ouroboros.app ) and run xattr -d com.apple.quarantine Ouroboros.app .","title":"Download Ouroboros"},{"location":"guide/plugins/","text":"Ouroboros Plugins Recommended Plugins Neuroglancer Plugin Embeds Neuroglancer as a page in the app. Supports loading from and saving to JSON configuration files in Ouroboros's File Explorer. Has additional features like fullscreen mode and screenshots. Assisted Automatic Segmentation Plugin Coming Soon! Based on Segment Anything, it attempts to automatically segment the ROI. Benefits from the assumption that the desired structure is centered in each slice. Supports human input via bounding boxes and positive or negative annotations. Installing a Plugin Open the Plugin Manager: File > Manage Plugins . Press the Plus Icon Paste the GitHub URL of the plugin. Press Download (Ouroboros downloads and installs the plugin for you) Where are plugins installed? In the appData /ouroboros folder. This folder is different on each OS. Creating a Plugin See the template README for more information.","title":"Plugins"},{"location":"guide/plugins/#ouroboros-plugins","text":"","title":"Ouroboros Plugins"},{"location":"guide/plugins/#recommended-plugins","text":"Neuroglancer Plugin Embeds Neuroglancer as a page in the app. Supports loading from and saving to JSON configuration files in Ouroboros's File Explorer. Has additional features like fullscreen mode and screenshots. Assisted Automatic Segmentation Plugin Coming Soon! Based on Segment Anything, it attempts to automatically segment the ROI. Benefits from the assumption that the desired structure is centered in each slice. Supports human input via bounding boxes and positive or negative annotations.","title":"Recommended Plugins"},{"location":"guide/plugins/#installing-a-plugin","text":"Open the Plugin Manager: File > Manage Plugins . Press the Plus Icon Paste the GitHub URL of the plugin. Press Download (Ouroboros downloads and installs the plugin for you) Where are plugins installed? In the appData /ouroboros folder. This folder is different on each OS.","title":"Installing a Plugin"},{"location":"guide/plugins/#creating-a-plugin","text":"See the template README for more information.","title":"Creating a Plugin"},{"location":"guide/slicing/","text":"Slicing Slicing is one of the primary features of Ouroboros, available in the CLI and the desktop app. Using the Slice Page Basic Usage Demo Reusing Options from a Previous Run Slicing Options \ud83d\udcc1 - Drag and drop files from File Explorer panel into this option. \ud83d\udcc1 Neuroglancer JSON - Path to the Neuroglancer configuration JSON file (exported from Neuroglancer with {} icon, or through the Neuroglancer Plugin) Neuroglancer Image Layer - Select Neuroglancer image layer to slice from. Neuroglancer Annotation Layer - Select Neuroglancer annotation layer to slice from. Slice Width - The output width of each slice image. Slice Height - The output height of each slice image. \ud83d\udcc1 Output File Folder - The folder to save all the resulting files into. Output File Name - Base name for all output files. Annotation MIP Level - The annotation layer's MIP level. 0 is the highest resolution. Output MIP Level - The MIP level to output slices in (essentially a downsample option). 1 is a good starting point. Slicing Parameters Distance Between Slices - The distance between each slice along the annotation path. Use Adaptive Slicing - Rather than just using equidistant slices, add more slices in more curved areas. Adaptive Slicing Ratio - 1 indicates to consider distance and curvature equally, 0.5 is biased towards distance, and 2 is biased towards curvature. Output Single File - Whether to output one tiff stack file or a folder of files. Bounding Box Parameters Max Depth - The maximum depth for binary space partitioning. It is not recommended to change this option unless you encounter RAM issues. Target Slices Per Box - If you are running on a low-RAM system, or you are taking very large slices, you may want to decrease this. Max RAM (GB) - 0 indicates no RAM limit. Setting a RAM limit allows Ouroboros to optimize performance and avoid overusing RAM. How Does Slicing Work? Spline Fitting Ouroboros fits a spline curve to the annotation path from the Neuroglancer JSON file. This produces a smooth, differentiable curve along the length of the annotations. If the line segments between annotation points were used, then there would could be highly discontinuous slice transitions around sharp corners. Slice Coordinate Frames Ouroboros calculates equidistant points along the spline curve. Each point is \"1\" apart from the previous to match the appearance of isotropic slices taken from one of the axes of the coordinate space of the full volume (the coordinate space of the annotation points). To follow any possible path, each point must have its own coordinate frame normal to the spline. For easier segmentation, it is also important that the axes of the point coordinate frames don't flip between points. To achieve this, Ouroboros calculates rotation-minimizing frames based on the change in orientation of the tangent vectors of adjacent points. Rectangles and Grids Ouroboros calculates the corners of the slice rectangle at using each point and its associated coordinate axes (as vectors). Pseudocode width_vector # 'u' unit vector scaled to slice width / 2 height_vector # 'v' unit vector scaled to slice height / 2 top_left = point - width_vector + height_vector top_right = point + width_vector + height_vector bottom_right = point + width_vector - height_vector bottom_left = point - width_vector - height_vector Then, for each point, a 2D grid is generated with given dimensions (slice width and height). Each point in the 2D grid is a 3D point which is calculated by interpolating between the four corner points. Volumes and Trilinear Interpolation At this point, Ouroboros has a full grid of 3D points associated with each slice, but has yet to download any data from the cloud-hosted volume. To avoid downloading unnecessary data, Ouroboros employs binary space partitioning to divide the minimum bounding box of the ROI recursively until each volume contains few enough slices to fit into available RAM. Ouroboros then downloads the data for each of these bounding boxes from the cloud-hosted volume. As each download completes, a new process is spawned to handle calculations. For each volume, scipy.ndimage.map_coordinates is used to extract the values at the coordinates of the slice grids from the 3D volume using trilinear interpolation. Each of these slices are saved as local tiff images and are later combined into a single output tiff.","title":"Slicing"},{"location":"guide/slicing/#slicing","text":"Slicing is one of the primary features of Ouroboros, available in the CLI and the desktop app.","title":"Slicing"},{"location":"guide/slicing/#using-the-slice-page","text":"Basic Usage Demo Reusing Options from a Previous Run","title":"Using the Slice Page"},{"location":"guide/slicing/#slicing-options","text":"\ud83d\udcc1 - Drag and drop files from File Explorer panel into this option. \ud83d\udcc1 Neuroglancer JSON - Path to the Neuroglancer configuration JSON file (exported from Neuroglancer with {} icon, or through the Neuroglancer Plugin) Neuroglancer Image Layer - Select Neuroglancer image layer to slice from. Neuroglancer Annotation Layer - Select Neuroglancer annotation layer to slice from. Slice Width - The output width of each slice image. Slice Height - The output height of each slice image. \ud83d\udcc1 Output File Folder - The folder to save all the resulting files into. Output File Name - Base name for all output files. Annotation MIP Level - The annotation layer's MIP level. 0 is the highest resolution. Output MIP Level - The MIP level to output slices in (essentially a downsample option). 1 is a good starting point. Slicing Parameters Distance Between Slices - The distance between each slice along the annotation path. Use Adaptive Slicing - Rather than just using equidistant slices, add more slices in more curved areas. Adaptive Slicing Ratio - 1 indicates to consider distance and curvature equally, 0.5 is biased towards distance, and 2 is biased towards curvature. Output Single File - Whether to output one tiff stack file or a folder of files. Bounding Box Parameters Max Depth - The maximum depth for binary space partitioning. It is not recommended to change this option unless you encounter RAM issues. Target Slices Per Box - If you are running on a low-RAM system, or you are taking very large slices, you may want to decrease this. Max RAM (GB) - 0 indicates no RAM limit. Setting a RAM limit allows Ouroboros to optimize performance and avoid overusing RAM.","title":"Slicing Options"},{"location":"guide/slicing/#how-does-slicing-work","text":"Spline Fitting Ouroboros fits a spline curve to the annotation path from the Neuroglancer JSON file. This produces a smooth, differentiable curve along the length of the annotations. If the line segments between annotation points were used, then there would could be highly discontinuous slice transitions around sharp corners. Slice Coordinate Frames Ouroboros calculates equidistant points along the spline curve. Each point is \"1\" apart from the previous to match the appearance of isotropic slices taken from one of the axes of the coordinate space of the full volume (the coordinate space of the annotation points). To follow any possible path, each point must have its own coordinate frame normal to the spline. For easier segmentation, it is also important that the axes of the point coordinate frames don't flip between points. To achieve this, Ouroboros calculates rotation-minimizing frames based on the change in orientation of the tangent vectors of adjacent points. Rectangles and Grids Ouroboros calculates the corners of the slice rectangle at using each point and its associated coordinate axes (as vectors). Pseudocode width_vector # 'u' unit vector scaled to slice width / 2 height_vector # 'v' unit vector scaled to slice height / 2 top_left = point - width_vector + height_vector top_right = point + width_vector + height_vector bottom_right = point + width_vector - height_vector bottom_left = point - width_vector - height_vector Then, for each point, a 2D grid is generated with given dimensions (slice width and height). Each point in the 2D grid is a 3D point which is calculated by interpolating between the four corner points. Volumes and Trilinear Interpolation At this point, Ouroboros has a full grid of 3D points associated with each slice, but has yet to download any data from the cloud-hosted volume. To avoid downloading unnecessary data, Ouroboros employs binary space partitioning to divide the minimum bounding box of the ROI recursively until each volume contains few enough slices to fit into available RAM. Ouroboros then downloads the data for each of these bounding boxes from the cloud-hosted volume. As each download completes, a new process is spawned to handle calculations. For each volume, scipy.ndimage.map_coordinates is used to extract the values at the coordinates of the slice grids from the 3D volume using trilinear interpolation. Each of these slices are saved as local tiff images and are later combined into a single output tiff.","title":"How Does Slicing Work?"}]}